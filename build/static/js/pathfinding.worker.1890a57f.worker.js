(()=>{"use strict";function e(e,s,i){const h=[];s.distance=0;const n=new class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:(e,t)=>e.f-t.f;this.heap=[null],this.comparator=e}enqueue(e){this.heap.push(e),this.bubbleUp()}dequeue(){const e=this.heap[1];return this.heap[1]=this.heap[this.heap.length-1],this.heap.pop(),this.sinkDown(),e}bubbleUp(){let e=this.heap.length-1;for(;e>1&&this.comparator(this.heap[Math.floor(e/2)],this.heap[e])>0;)[this.heap[Math.floor(e/2)],this.heap[e]]=[this.heap[e],this.heap[Math.floor(e/2)]],e=Math.floor(e/2)}sinkDown(){let e=1;for(;2*e<this.heap.length;){let t=2*e;if(2*e+1<this.heap.length&&this.comparator(this.heap[2*e+1],this.heap[2*e])<0&&(t=2*e+1),!(this.comparator(this.heap[t],this.heap[e])<0))break;[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]],e=t}}decreaseKey(e,t){let s=this.heap.findIndex((t=>t===e));-1!==s&&(this.heap[s].distance=t,this.bubbleUp())}contains(e){return this.heap.includes(e)}isEmpty(){return 1===this.heap.length}}(((e,t)=>e.distance-t.distance));for(n.enqueue(s);!n.isEmpty();){const s=n.dequeue();if(!s.isWall){if(s.distance===1/0)return h;if(s.isVisited=!0,h.push(s),s===i)return h;t(s,e,n)}}}function t(e,t,s){const i=function(e,t){const s=[],{col:i,row:h}=e;h>0&&s.push(t[h-1][i]);h<t.length-1&&s.push(t[h+1][i]);i>0&&s.push(t[h][i-1]);i<t[0].length-1&&s.push(t[h][i+1]);return s}(e,t);for(const h of i){if(h.isVisited)continue;const t=e.distance+1;t<h.distance&&(h.distance=t,h.previousNode=e,s.contains(h)?s.decreaseKey(h,t):s.enqueue(h))}}function s(e,t,s){const n=new class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:(e,t)=>e.f-t.f;this.heap=[null],this.comparator=e,this.nodeIndices=new Map}enqueue(e){this.heap.push(e),this.nodeIndices.set(e,this.heap.length-1),this.bubbleUp()}dequeue(){const e=this.heap[1];return this.nodeIndices.delete(e),this.heap[1]=this.heap[this.heap.length-1],this.nodeIndices.set(this.heap[1],1),this.heap.pop(),this.sinkDown(),e}bubbleUp(){let e=this.heap.length-1;for(;e>1&&this.comparator(this.heap[Math.floor(e/2)],this.heap[e])>0;)this.nodeIndices.set(this.heap[Math.floor(e/2)],e),this.nodeIndices.set(this.heap[e],Math.floor(e/2)),[this.heap[Math.floor(e/2)],this.heap[e]]=[this.heap[e],this.heap[Math.floor(e/2)]],e=Math.floor(e/2)}sinkDown(){let e=1;for(;2*e<this.heap.length;){let t=2*e;if(2*e+1<this.heap.length&&this.comparator(this.heap[2*e+1],this.heap[2*e])<0&&(t=2*e+1),!(this.comparator(this.heap[t],this.heap[e])<0))break;this.nodeIndices.set(this.heap[t],e),this.nodeIndices.set(this.heap[e],t),[this.heap[t],this.heap[e]]=[this.heap[e],this.heap[t]],e=t}}decreaseKey(e,t){let s=this.nodeIndices.get(e);void 0!==s&&(this.heap[s].distance=t,this.bubbleUp())}contains(e){return this.nodeIndices.has(e)}isEmpty(){return 1===this.heap.length}}(((e,t)=>e.f-t.f)),o=new Set,a=[];for(t.distance=0,t.h=i(t,s),t.f=t.h,n.enqueue(t);!n.isEmpty();){const t=n.dequeue();if(o.add(t),a.push(t),t===s)return a;const r=h(t,e);for(const e of r){if(o.has(e)||e.isWall)continue;const h=t.distance+1,a=e.h||i(e,s);e.h=a,n.contains(e)?h<e.distance&&(e.distance=h,e.f=h+a,e.previousNode=t,n.decreaseKey(e,e.f)):(n.enqueue(e),e.distance=h,e.f=h+a,e.previousNode=t)}}return a}function i(e,t){return Math.abs(e.row-t.row)+Math.abs(e.col-t.col)}function h(e,t){const s=[],{col:i,row:h}=e;return h>0&&s.push(t[h-1][i]),h<t.length-1&&s.push(t[h+1][i]),i>0&&s.push(t[h][i-1]),i<t[0].length-1&&s.push(t[h][i+1]),s.filter((e=>!e.isVisited))}function n(e,t,s){const i=[],h=[];for(t.distance=0,h.push(t);0!==h.length;){const t=h.shift();if(t.isWall)continue;if(t.distance===1/0)return i;if(t.isVisited=!0,i.push(t),t===s)return i;const n=o(t,e);for(const e of n)e.distance=t.distance+1,e.previousNode=t,e.isVisited=!0,h.push(e)}}function o(e,t){const s=[],{col:i,row:h}=e;return h>0&&s.push(t[h-1][i]),h<t.length-1&&s.push(t[h+1][i]),i>0&&s.push(t[h][i-1]),i<t[0].length-1&&s.push(t[h][i+1]),s.filter((e=>!e.isVisited))}function a(e,t,s){const i=[];t.distance=0;const h=[t];for(;h.length;){const t=h.pop();if(t.isWall)continue;if(t.distance===1/0)return i;if(t.isVisited=!0,i.push(t),t===s)return i;const n=r(t,e);for(const e of n)e.distance=t.distance+1,e.previousNode=t,h.push(e)}}function r(e,t){const s=[],{col:i,row:h}=e;return h>0&&s.push(t[h-1][i]),h<t.length-1&&s.push(t[h+1][i]),i>0&&s.push(t[h][i-1]),i<t[0].length-1&&s.push(t[h][i+1]),s.filter((e=>!e.isVisited))}function c(e,t,s){const i=[];t.distance=0;let h=t,n=null;for(;h!==s;){h.isVisited=!0,h.noOfVisits=(h.noOfVisits||0)+1,i.push(h);const t=p(h,e);let s=null;for(const e of t)if(e!==n&&!e.isWall){s=e;break}if(s)s.distance=h.distance+1,s.previousNode=h,n=h,h=s;else{if(!n)break;h=n,n=h.previousNode}}return i}function p(e,t){const s=[],{col:i,row:h}=e;return h>0&&s.push(t[h-1][i]),h<t.length-1&&s.push(t[h+1][i]),i>0&&s.push(t[h][i-1]),i<t[0].length-1&&s.push(t[h][i+1]),s.filter((e=>!e.isVisited))}self.addEventListener("message",(t=>{const{algorithmName:i,grid:h,startNode:o,endNode:r}=t.data;let p;switch(i){case"dijkstra":p=e;break;case"astar":p=s;break;case"bfs":p=n;break;case"dfs":p=a;break;case"wallFollower":p=c;break;default:console.log("No such algorithm")}const u=performance.now(),l=p(h,o,r),d=performance.now(),f=function(e){const t=[];let s=e;for(;null!==s;)t.unshift(s),s=s.previousNode;return t}(r);self.postMessage({visitedNodesInOrder:l,nodesInShortestPathOrder:f,startTime:u,endTime:d})}))})();
//# sourceMappingURL=pathfinding.worker.1890a57f.worker.js.map