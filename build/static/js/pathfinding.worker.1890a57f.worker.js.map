{"version":3,"file":"static/js/pathfinding.worker.1890a57f.worker.js","mappings":"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","sources":["Algorithms/dijkstra.js","Algorithms/astar.js","Algorithms/bfs.js","Algorithms/dfs.js","Algorithms/wall_follower.js","PathfindingVisualizer/pathfinding.worker.js"],"sourcesContent":["export function dijkstra(grid, startNode, endNode) {\n    class PriorityQueue {\n        constructor(comparator = (a, b) => a.f - b.f) {\n            this.heap = [null];\n            this.comparator = comparator;\n        }\n\n        enqueue(node) {\n            this.heap.push(node);\n            this.bubbleUp();\n        }\n\n        dequeue() {\n            const min = this.heap[1];\n            this.heap[1] = this.heap[this.heap.length - 1];\n            this.heap.pop();\n            this.sinkDown();\n            return min;\n        }\n\n        bubbleUp() {\n            let index = this.heap.length - 1;\n            while (index > 1 && this.comparator(this.heap[Math.floor(index / 2)], this.heap[index]) > 0) {\n                [this.heap[Math.floor(index / 2)], this.heap[index]] = [this.heap[index], this.heap[Math.floor(index / 2)]];\n                index = Math.floor(index / 2);\n            }\n        }\n\n        sinkDown() {\n            let index = 1;\n            while (index * 2 < this.heap.length) {\n                let smallerIndex = index * 2;\n                if (index * 2 + 1 < this.heap.length && this.comparator(this.heap[index * 2 + 1], this.heap[index * 2]) < 0) {\n                    smallerIndex = index * 2 + 1;\n                }\n                if (this.comparator(this.heap[smallerIndex], this.heap[index]) < 0) {\n                    [this.heap[smallerIndex], this.heap[index]] = [this.heap[index], this.heap[smallerIndex]];\n                    index = smallerIndex;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        decreaseKey(node, newDistance) {\n            let index = this.heap.findIndex((element) => element === node);\n            if (index === -1) return;\n            this.heap[index].distance = newDistance;\n            this.bubbleUp();\n        }\n\n        contains(node) {\n            return this.heap.includes(node);\n        }\n\n        isEmpty() {\n            return this.heap.length === 1;\n        }\n    }\n\n\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisitedNodes = new PriorityQueue((a, b) => a.distance - b.distance);\n    unvisitedNodes.enqueue(startNode);\n\n    while (!unvisitedNodes.isEmpty()) {\n        const closestNode = unvisitedNodes.dequeue();\n\n        // If there is a wall, skip it\n        if (closestNode.isWall) continue;\n        // If distance is infinity, we are trapped and should stop\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n\n        closestNode.isVisited = true;\n        visitedNodesInOrder.push(closestNode);\n        if (closestNode === endNode) return visitedNodesInOrder;\n        updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes);\n    }\n}\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        if (neighbor.isVisited) continue; // Skip if the neighbor is visited\n\n        const newDistance = node.distance + 1;\n        if (newDistance < neighbor.distance) {\n            neighbor.distance = newDistance;\n            neighbor.previousNode = node;\n            if (!unvisitedNodes.contains(neighbor)) {\n                unvisitedNodes.enqueue(neighbor);\n            } else {\n                unvisitedNodes.decreaseKey(neighbor, newDistance);\n            }\n        }\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { col, row } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors;\n}\n\n","export function astar(grid, startNode, endNode) {\n    class PriorityQueue {\n        constructor(comparator = (a, b) => a.f - b.f) {\n            this.heap = [null];\n            this.comparator = comparator;\n            this.nodeIndices = new Map();\n        }\n\n        enqueue(node) {\n            this.heap.push(node);\n            this.nodeIndices.set(node, this.heap.length - 1);\n            this.bubbleUp();\n        }\n\n        dequeue() {\n            const min = this.heap[1];\n            this.nodeIndices.delete(min);\n            this.heap[1] = this.heap[this.heap.length - 1];\n            this.nodeIndices.set(this.heap[1], 1);\n            this.heap.pop();\n            this.sinkDown();\n            return min;\n        }\n\n        bubbleUp() {\n            let index = this.heap.length - 1;\n            while (index > 1 && this.comparator(this.heap[Math.floor(index / 2)], this.heap[index]) > 0) {\n                this.nodeIndices.set(this.heap[Math.floor(index / 2)], index);\n                this.nodeIndices.set(this.heap[index], Math.floor(index / 2));\n                [this.heap[Math.floor(index / 2)], this.heap[index]] = [this.heap[index], this.heap[Math.floor(index / 2)]];\n                index = Math.floor(index / 2);\n            }\n        }\n\n        sinkDown() {\n            let index = 1;\n            while (index * 2 < this.heap.length) {\n                let smallerIndex = index * 2;\n                if (index * 2 + 1 < this.heap.length && this.comparator(this.heap[index * 2 + 1], this.heap[index * 2]) < 0) {\n                    smallerIndex = index * 2 + 1;\n                }\n                if (this.comparator(this.heap[smallerIndex], this.heap[index]) < 0) {\n                    this.nodeIndices.set(this.heap[smallerIndex], index);\n                    this.nodeIndices.set(this.heap[index], smallerIndex);\n                    [this.heap[smallerIndex], this.heap[index]] = [this.heap[index], this.heap[smallerIndex]];\n                    index = smallerIndex;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        decreaseKey(node, newDistance) {\n            let index = this.nodeIndices.get(node);\n            if (index === undefined) return;\n            this.heap[index].distance = newDistance;\n            this.bubbleUp();\n        }\n\n        contains(node) {\n            return this.nodeIndices.has(node);\n        }\n\n        isEmpty() {\n            return this.heap.length === 1;\n        }\n    }\n\n    const openList = new PriorityQueue((a, b) => a.f - b.f);\n    const closedList = new Set();\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    startNode.h = heuristic(startNode, endNode);\n    startNode.f = startNode.h;\n    openList.enqueue(startNode);\n    while (!openList.isEmpty()) {\n        const currentNode = openList.dequeue();\n        closedList.add(currentNode);\n        visitedNodesInOrder.push(currentNode);\n        if (currentNode === endNode) {\n            return visitedNodesInOrder;\n        }\n        const neighbors = getUnvisitedNeighbors(currentNode, grid);\n        for (const neighbor of neighbors) {\n            if (closedList.has(neighbor) || neighbor.isWall) continue;\n            const gScore = currentNode.distance + 1;\n            const hScore = neighbor.h || heuristic(neighbor, endNode);\n            neighbor.h = hScore;\n            if (!openList.contains(neighbor)) {\n                openList.enqueue(neighbor);\n                neighbor.distance = gScore;\n                neighbor.f = gScore + hScore;\n                neighbor.previousNode = currentNode;\n            } else if (gScore < neighbor.distance) {\n                neighbor.distance = gScore;\n                neighbor.f = gScore + hScore;\n                neighbor.previousNode = currentNode;\n                openList.decreaseKey(neighbor, neighbor.f);\n            }\n        }\n    }\n    return visitedNodesInOrder;\n}\n\nfunction heuristic(node, endNode) {\n    return Math.abs(node.row - endNode.row) + Math.abs(node.col - endNode.col);\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { col, row } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n","export function bfs(grid, startNode, endNode) {\n    const visitedNodesInOrder = [];\n    const queue = [];\n    startNode.distance = 0;\n    queue.push(startNode);\n    while (queue.length !== 0) {\n        const currentNode = queue.shift();\n        if (currentNode.isWall) continue;\n        if (currentNode.distance === Infinity) return visitedNodesInOrder;\n        currentNode.isVisited = true;\n        visitedNodesInOrder.push(currentNode);\n        if (currentNode === endNode) return visitedNodesInOrder;\n        const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n        for (const neighbor of unvisitedNeighbors) {\n            neighbor.distance = currentNode.distance + 1;\n            neighbor.previousNode = currentNode;\n            neighbor.isVisited = true;  // Mark as visited here\n            queue.push(neighbor);\n        }\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}","export function dfs(grid, startNode, endNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const stack = [startNode];\n    while (stack.length) {\n        const currentNode = stack.pop();\n        if (currentNode.isWall) continue;\n        if (currentNode.distance === Infinity) return visitedNodesInOrder;\n        currentNode.isVisited = true;\n        visitedNodesInOrder.push(currentNode);\n        if (currentNode === endNode) return visitedNodesInOrder;\n        const unvisitedNeighbors = getUnvisitedNeighbors(currentNode, grid);\n        for (const neighbor of unvisitedNeighbors) {\n            neighbor.distance = currentNode.distance + 1;\n            neighbor.previousNode = currentNode;\n            stack.push(neighbor);\n        }\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { col, row } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}","export function wallFollower(grid, startNode, endNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    let currentNode = startNode;\n    let previousNode = null;\n    while (currentNode !== endNode) {\n        currentNode.isVisited = true;\n        currentNode.noOfVisits = (currentNode.noOfVisits || 0) + 1; // increment visit count\n        visitedNodesInOrder.push(currentNode);\n        const neighbors = getUnvisitedNeighbors(currentNode, grid);\n        let nextNode = null;\n        for (const neighbor of neighbors) {\n            if (neighbor !== previousNode && !neighbor.isWall) {\n                nextNode = neighbor;\n                break;\n            }\n        }\n        if (nextNode) {\n            nextNode.distance = currentNode.distance + 1;\n            nextNode.previousNode = currentNode;\n            previousNode = currentNode;\n            currentNode = nextNode;\n        } else {\n            if (previousNode) {\n                currentNode = previousNode;\n                previousNode = currentNode.previousNode;\n            } else {\n                break;\n            }\n        }\n    }\n    return visitedNodesInOrder;\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { col, row } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n","/* eslint no-restricted-globals: [\"error\", \"never\"] */\n\nimport { dijkstra } from '../Algorithms/dijkstra.js';\nimport { astar } from '../Algorithms/astar.js';\nimport { bfs } from '../Algorithms/bfs.js';\nimport { dfs } from '../Algorithms/dfs.js';\nimport { wallFollower } from '../Algorithms/wall_follower.js';\n\nself.addEventListener('message', (event) => {\n  const { algorithmName, grid, startNode, endNode } = event.data;\n  let algorithm;\n  switch (algorithmName) {\n    case 'dijkstra':\n      algorithm = dijkstra;\n      break;\n    case 'astar':\n      algorithm = astar;\n      break;\n    case 'bfs':\n      algorithm = bfs;\n      break;\n    case 'dfs':\n      algorithm = dfs;\n      break;\n    case 'wallFollower':\n      algorithm = wallFollower;\n      break;\n    default:\n      console.log(\"No such algorithm\");\n      break;\n  }\n  const startTime = performance.now();\n  const visitedNodesInOrder = algorithm(grid, startNode, endNode);\n  const endTime = performance.now();\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(endNode);\n\n  self.postMessage({ visitedNodesInOrder, nodesInShortestPathOrder, startTime, endTime });\n});\n\nfunction getNodesInShortestPathOrder(endNode) {\n  // Implement this function based on your Node class and how you're storing the path\n  // This is just a placeholder implementation\n  const nodesInShortestPathOrder = [];\n  let currentNode = endNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n"],"names":["dijkstra","grid","startNode","endNode","visitedNodesInOrder","distance","unvisitedNodes","constructor","comparator","arguments","length","undefined","a","b","f","this","heap","enqueue","node","push","bubbleUp","dequeue","min","pop","sinkDown","index","Math","floor","smallerIndex","decreaseKey","newDistance","findIndex","element","contains","includes","isEmpty","closestNode","isWall","Infinity","isVisited","updateUnvisitedNeighbors","unvisitedNeighbors","neighbors","col","row","getUnvisitedNeighbors","neighbor","previousNode","astar","openList","nodeIndices","Map","set","delete","get","has","closedList","Set","h","heuristic","currentNode","add","gScore","hScore","abs","filter","bfs","queue","shift","dfs","stack","wallFollower","noOfVisits","nextNode","self","addEventListener","event","algorithmName","data","algorithm","console","log","startTime","performance","now","endTime","nodesInShortestPathOrder","unshift","getNodesInShortestPathOrder","postMessage"],"sourceRoot":""}